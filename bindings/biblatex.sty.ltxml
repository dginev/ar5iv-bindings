# -*- CPERL -*-
# /=====================================================================\ #
# |  biblatex.sty                                                       | #
# | Implementation for LaTeXML                                          | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | Deyan Ginev <deyan.ginev@nist.gov>                          #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #
package LaTeXML::Package::Pool;
use strict;
use warnings;
use LaTeXML::Package;

#**********************************************************************

Warn('missing_file', 'biblatex.sty', $STATE->getStomach->getGullet,
  'biblatex.sty is not implemented and will not be interpreted raw.');

#**********************************************************************

RequirePackage('url');
RequirePackage('natbib');
# \grqq ? from where?
RequirePackage('babel_support');

# Forbid loading this package, even locally, until we get our
# own bibliography support hooked in.
#InputDefinitions('biblatex', type => 'sty', noltxml => 1);

# TODO: Alternative citation styles
DefMacro('\parencite',    '\cite');
DefMacro('\parencites',   '\cite');
DefMacro('\fullcite',     '\cite');
DefMacro('\footcite',     '\cite');
DefMacro('\footcitetext', '\cite');
DefMacro('\smartcite',    '\cite');
DefMacro('\textcite',     '\cite');
DefMacro('\supercite',    '\cite');

DefMacro('\unspace',                '\relax');     # ?
DefMacro('\blx@imc@resetpunctfont', '\relax');     # ?
DefMacro('\blx@postpunct',          '\@empty');    # ?
DefRegister('\c@highnamepenalty' => Number(0));

DefMacro('\addslash', '/\hskip\z@skip');
DefMacro('\adddot',   '.');

# ?
DefMacro('\addspace',        '\space');
DefMacro('\addnbspace',      '\space');
DefMacro('\addthinspace',    '\space');
DefMacro('\addnbthinspace',  '\space');
DefMacro('\addlowpenspace',  '\space');
DefMacro('\addhighpenspace', '\space');
DefMacro('\addlpthinspace',  '\space');
DefMacro('\addhpthinspace',  '\space');
DefMacro('\addabbrvspace',   '\space');
DefMacro('\addabthinspace',  '\space');
DefMacro('\adddotspace',     '\unspace\adddot\space');

DefMacro('\noligature',   '\nobreak\hskip\z@skip');
DefMacro('\hyphen',       '\nobreak-\nobreak\hskip\z@skip');
DefMacro('\nbhyphen',     '\nobreak\mbox{-}\nobreak\hskip\z@skip');
DefMacro('\hyphenate',    '\nobreak\-\nobreak\hskip\z@skip');
DefMacro('\allowhyphens', '\nobreak\hskip\z@skip');

DefMacro('\bibinitperiod',      '\adddot');
DefMacro('\bibinithyphendelim', '.\mbox{-}');
DefMacro('\bibnamedelima',      '\addhighpenspace');
DefMacro('\bibnamedelimb',      '\addlowpenspace');
DefMacro('\bibnamedelimc',      '\addhighpenspace');
DefMacro('\bibnamedelimd',      '\addlowpenspace');
DefMacro('\bibnamedelimi',      '\addnbspace');

DefMacro('\datalist[]{}', '', locked => 1);
DefMacro('\sortlist[]{}', '', locked => 1);
DefMacro('\lossort',      '', locked => 1);
DefMacro('\refsection{}', '', locked => 1);

sub biblatex_as_thebibliography {
  return (
    T_CS('\thebibliography'), T_BEGIN, T_OTHER(LookupValue('biblatex_entry_count')), T_END,
    @{ LookupValue('rebuilt_bibtex_variant') || [] },
    T_CS('\endthebibliography')); }

DefMacro('\enddatalist',   \&biblatex_as_thebibliography, locked => 1);
DefMacro('\endsortlist',   \&biblatex_as_thebibliography, locked => 1);
DefMacro('\endlossort',    \&biblatex_as_thebibliography, locked => 1);
DefMacro('\endrefsection', \&biblatex_as_thebibliography, locked => 1);

DefMacro('\entry{}{}{}', sub {
    AssignValue('biblatex_entry', {
        key => $_[1], type => $_[2] }, 'global');
    return; }, locked => 1);

DefMacro('\endentry', sub {
    my ($gullet) = @_;
    my $entry = LookupValue('biblatex_entry') || {};
    # reset entry just in case
    AssignValue('biblatex_entry', undef, 'global');
    my $label = $$entry{'labelalpha'};
    # let's say we can not yet find the right label,
    # as the biblatex support here is minimal.
    # Rather than failing loudly, let's make a simple default one.
    if (!$label) {
      my $label_int = 1 + (LookupValue('biblatex_auto_label') || 0);
      AssignValue('biblatex_auto_label', $label_int, 'global');
      $label = T_OTHER("$label_int"); }

    # record this for {thebibliography}
    AssignValue('biblatex_entry_count', 1 + (LookupValue('biblatex_entry_count') || 0), 'global');

    my $variant = LookupValue('rebuilt_bibtex_variant') || [];
    push @$variant, (
      T_CS('\bibitem'), T_OTHER('['), $label, T_OTHER(']'), T_BEGIN, $$entry{key}, T_END);
    my $authors        = $$entry{authors};
    my @authors_tokens = ();
   # TODO: Important missing piece: we need to use the "namehash" to get the authors in the right order.
    my $author_count = scalar(keys %$authors);
    my $author_index = 0;
    # Two cases: either we have a DB-like hash,
    # or they were pre-typeset in "names"
    my @author_names = ();
    if ($$authors{names}) {
      @author_names = @{ $$authors{names} }; }
    else {
      my $hash_order = ToString($$entry{namehash} || $$entry{fullhash});
      $hash_order =~ s/^\s*//;
      $hash_order =~ s/\s*$//;
      my @author_keys = keys %$authors;
      # avoid infinite loops if we have bugs, generally it's a prefix code
    HASH_LOOP: while (@author_keys) {
        for my $key (@author_keys) {
          if ($hash_order =~ s/^$key//) {
            push(@author_names, $$authors{$key});
            @author_keys = grep { $_ ne $key } @author_keys;
            next HASH_LOOP; } }
        last; } }
    # Put all authors together.
    for my $author_name (@author_names) {
      $author_index += 1;
      if (@authors_tokens) {
        if ($author_index < $author_count) {
          push(@authors_tokens, T_OTHER(','), T_SPACE); }
        else {
          push(@authors_tokens, T_SPACE, T_OTHER('and'), T_SPACE); } }
      push(@authors_tokens, ExplodeText($author_name)); }
    push @$variant, @authors_tokens;
    # Add all other metadata fields that may be relevant.
    push @$variant, (T_CS('\newblock'), T_OTHER('`'), T_OTHER('`'), $$entry{title}, T_OTHER("'"), T_OTHER("'")) if $$entry{title};
    push @$variant, (T_SPACE, $$entry{note}) if $$entry{note};
    push @$variant, (T_CS('\newblock'), T_OTHER("In"), T_SPACE, T_CS('\emph'), T_BEGIN, $$entry{booktitle}, T_END) if $$entry{booktitle};
    if ($$entry{journaltitle}) {
      push @$variant, (T_CS('\newblock'), T_CS('\emph'), T_BEGIN, $$entry{journaltitle}, T_END);
      push @$variant, (T_SPACE, T_CS('\textbf'), T_BEGIN, $$entry{volume}, T_END) if $$entry{volume}; }
    if ($$entry{series}) {
      push @$variant, (T_OTHER(','), T_SPACE, $$entry{series});
      push @$variant, (T_SPACE, $$entry{number}) if $$entry{number}; }
    if ($$entry{publisher}) {
      push @$variant, T_CS('\newblock');
      push(@$variant, $$entry{location}, T_OTHER(":"), T_SPACE) if $$entry{location};
      push @$variant, $$entry{publisher}; }
    push @$variant, (T_OTHER(','), T_SPACE, $$entry{year}) if $$entry{year};
    push @$variant, (T_OTHER(','), T_SPACE, T_OTHER('pp.'), T_SPACE, $$entry{pages}) if $$entry{pages};
    if ($$entry{doi}) {
      my @doi = $$entry{doi}->unlist;
      # drop leading spaces for cleaner URI
      while ($doi[0] && $doi[0]->getCatcode eq CC_SPACE) {
        shift(@doi); }
      push @$variant, (T_CS('\newblock'), T_OTHER("DOI:"), T_SPACE,
        T_CS('\href'), T_BEGIN, T_OTHER("https://dx.doi.org/"), @doi, T_END, T_BEGIN, @doi, T_END); }
    elsif ($$entry{url}) {
      my $eprint_type = $$entry{eprinttype} ? T_OTHER(uc(ToString($$entry{eprinttype}))) : '';
      $eprint_type = T_OTHER("URL") unless $eprint_type;
      push @$variant, (T_CS('\newblock'), $eprint_type, T_OTHER(":"), T_SPACE, T_CS('\url'), T_BEGIN, $$entry{url}, T_END); }
    AssignValue('rebuilt_bibtex_variant', $variant, 'global');
    return ();
}, locked => 1);

DefKeyVal('BiblatexAuthor', 'given',   '');
DefKeyVal('BiblatexAuthor', 'giveni',  '');
DefKeyVal('BiblatexAuthor', 'family',  '');
DefKeyVal('BiblatexAuthor', 'familyi', '');

DefMacro('\name{}{}{}{}', sub {
    my ($gullet, $type, $count, $unk, $content) = @_;
    my $author_count = int(ToString($count));
    my %authors      = ();
    $gullet->unread($content->unlist);
    while ($author_count > 0) {
      $author_count--;
      my $author_arg = $gullet->readArg;
      $gullet->unread($author_arg->unlist);
      my $author_hash = $gullet->readArg;
      # If we are given a hash, expect keyvals
      if (ToString($author_hash) =~ /^hash=(.+)$/) {
        my $hash_value = $1;
        my $keyvals    = LaTeXML::Core::KeyVals->new(undef, 'BiblatexAuthor', setInternals => 1);
        $keyvals->readFrom($gullet, T_END);
        $authors{$hash_value} = ToString(Digest(Expand($keyvals->getValue('given') || $keyvals->getValue('giveni'))))
          . ' '
          . (ToString(Digest(Expand($keyvals->getValue('family') || $keyvals->getValue('familyi')))));
        # and drop any remaining braces.
        $authors{$hash_value} =~ s/[}{]//g; }

      # if $author_hash is empty, expect pre-laid out arguments
      else {
        my $family   = $gullet->readArg();
        my $familyi  = $gullet->readArg();
        my $given    = $gullet->readArg();
        my $giveni   = $gullet->readArg();
        my $discard1 = $gullet->readArg();
        my $discard2 = $gullet->readArg();
        my $discard3 = $gullet->readArg();
        my $discard4 = $gullet->readArg();
        $family  = ref $family  ? ToString(Digest(Expand($family->unlist)))  : '';
        $familyi = ref $familyi ? ToString(Digest(Expand($familyi->unlist))) : '';
        $given   = ref $given   ? ToString(Digest(Expand($given->unlist)))   : '';
        $giveni  = ref $giveni  ? ToString(Digest(Expand($giveni->unlist)))  : '';
        # what should be the key? should we try to refetch the hash?
        $authors{'names'} ||= [];
        push @{ $authors{'names'} }, ($given . ' ' . $family);
    } }

    # now that we have the authors, try to generate a sensible bibitem
    my $entry = LookupValue('biblatex_entry');
    $$entry{authors} = \%authors;
    return ();
}, locked => 1);

DefMacro('\list{}{}{}', sub {
    my $entry = LookupValue('biblatex_entry');
    # TODO: More support needed if $_[2] is greater than 1
    $$entry{ ToString($_[1]) } = Expand($_[3]);
    return; }, locked => 1);

DefMacro('\AtEveryBibitem{}',   '');
DefMacro('\keyw{}',             '');
DefMacro('\bibinitdelim',       '');
DefMacro('\bibinithyphendelim', '-');
DefMacro('\bibrangedash',       '-');
DefMacro('\bibnamedelimi',      ' ');
DefPrimitive('\field{}{}', sub {
    my $entry = LookupValue('biblatex_entry');
    $$entry{ ToString($_[1]) } = Expand($_[2]);
    return;
}, locked => 1);
DefPrimitive('\strng{}{}', sub {
    my $entry = LookupValue('biblatex_entry');
    $$entry{ ToString($_[1]) } = Expand($_[2]);
    return;
}, locked => 1);
DefMacro('\range{}{}', '');

sub init_verb {
  my ($gullet, $key) = @_;
  AssignValue('biblatex_verb_key', ToString($key), 'global');
  DefMacro('\verb', sub {
      PushValue('biblatex_verb_content', Explode($gullet->readRawLine())); });
  return (); }
DefMacro('\verb{}', \&init_verb);
DefMacro('\endverb', sub {
    my $entry        = LookupValue('biblatex_entry');
    my @verb_content = ();
    while (my $saved_content = PopValue('biblatex_verb_content')) {
      unshift(@verb_content, $saved_content); }
    $$entry{ LookupValue('biblatex_verb_key') } = Tokens(@verb_content);
    DefMacro('\verb{}', \&init_verb);
    return ();
}, locked => 1);
#**********************************************************************

DefPrimitive('\addbibresource{}', sub {
    my @file_list = split(/\s*,\s*/, ToString($_[1]));
    PushValue('biblatex_resources', @file_list);
    return; }, locked => 1);

DefMacro('\printbibliography[]', sub {
    my @resources = ();
    while (my $res = PopValue('biblatex_resources')) {
      push(@resources, T_OTHER(','), T_SPACE) if @resources;
      push(@resources, T_OTHER($res)); }
    return (T_CS('\bibliography'), T_BEGIN, @resources, T_END);
}, locked => 1);

DefPrimitive('\warn{}', sub {
    Info('biblatex', 'warn', ToString(Expand($_[1])));
    return; });

#************************************************************************
# language API : TODO?

DefMacro('\DeclareLanguageMapping{}{}',      '');
DefMacro('\DeclareLanguageMappingSuffix{}',  '');
DefMacro('\DefineHyphenationExceptions{}{}', '');
DefMacro('\DefineBibliographyExtras{}{}',    '');
DefMacro('\UndefineBibliographyExtras{}{}',  '');
DefMacro('\DefineBibliographyStrings{}{}',   '');

1;
